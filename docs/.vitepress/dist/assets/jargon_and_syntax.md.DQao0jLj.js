import{_ as a,c as i,o as t,ah as o}from"./chunks/framework.l_r_SdPt.js";const u=JSON.parse('{"title":"Documentation Jargon and Syntax","description":"","frontmatter":{},"headers":[],"relativePath":"jargon_and_syntax.md","filePath":"jargon_and_syntax.md"}'),r={name:"jargon_and_syntax.md"};function l(n,e,d,s,c,h){return t(),i("div",null,[...e[0]||(e[0]=[o('<h1 id="documentation-jargon-and-syntax" tabindex="-1">Documentation Jargon and Syntax <a class="header-anchor" href="#documentation-jargon-and-syntax" aria-label="Permalink to “Documentation Jargon and Syntax”">​</a></h1><h2 id="general" tabindex="-1">General <a class="header-anchor" href="#general" aria-label="Permalink to “General”">​</a></h2><ul><li>White space agnostic.</li><li>Comments can be line level (<code>//</code> until end of line) or block level (<code>/*</code> until <code>*/</code>). These can occur anywhere.</li><li>Three types of bracket pairs are used: <ul><li><code>()</code>: macro/fn args and condition statements</li><li><code>[]</code>: arrays, action param expansions</li><li><code>{}</code>: block bodies</li></ul></li><li>Trailing commas are allowed in arrays, expansions, fn args, etc. <ul><li>They are <em>not</em> allowed in JSON literals.</li></ul></li><li>Actions and other phrases that don&#39;t end with a closing bracket (<code>]</code>, <code>)</code>, <code>}</code>) are instead ended with a semicolon (<code>;</code>). This helps the parser disambiguate incomplete phrases.</li><li>Dialog, serial dialog, and almost all script references can be defined in place, e.g. <ul><li><code>show dialog dialogName;</code> (bare identifier)</li><li><code>show dialog dialogName { PLAYER &quot;Hi!&quot; };</code> (identifier and definition)</li><li><code>show dialog { PLAYER &quot;Hi!&quot; };</code> (anonymous definition)</li><li>Note that a semicolon is still required in the latter two cases because the &quot;script literal&quot; is part of an action phrase, which still needs to end in a semicolon.</li></ul></li></ul><h2 id="style-guide" tabindex="-1">Style Guide <a class="header-anchor" href="#style-guide" aria-label="Permalink to “Style Guide”">​</a></h2><ul><li>My personal naming convention for identifiers is <code>camel_case</code> but there is no grammatical requirement for any particular paradigm.</li><li>Keeping identifiers as barewords helps legibility, so is currently preferred. <ul><li>Barewords may no longer contain hyphen (<code>-</code>), a word breaking character, because it made renaming identifiers en masse difficult. (No language server!) Most such cases were replaced with <code>_</code> but not all. All remaining cases are wrapped in double quotes at least, which will make it easier to rename them than before.</li></ul></li><li>Using language keywords like <code>player</code> is preferred to the long form (<code>entity &quot;%PLAYER%&quot;</code>).</li></ul><h2 id="jargon" tabindex="-1">Jargon <a class="header-anchor" href="#jargon" aria-label="Permalink to “Jargon”">​</a></h2><h3 id="token" tabindex="-1">Token <a class="header-anchor" href="#token" aria-label="Permalink to “Token”">​</a></h3><p>A unit of text the parser considers to be a single word or word-ish unit.</p><ul><li>Tokens have <a href="./primitive_types.html">types</a> at the grammar level.</li><li><code>entity &quot;Bob&quot; x</code> = three tokens, all three strings (types <a href="./primitive_types.html#bareword">bareword</a>, <a href="./primitive_types.html#quoted-string">quoted string</a>, <a href="./primitive_types.html#bareword">bareword</a>)</li><li><code>#00FF00</code> = one token, type <a href="./primitive_types.html#color">color</a></li></ul><h3 id="argument" tabindex="-1">Argument <a class="header-anchor" href="#argument" aria-label="Permalink to “Argument”">​</a></h3><ul><li>Also called <strong>arg</strong>.</li><li>A value handed to a fn (much like a normal function arg), or the secondary word(s) after a command verb.</li></ul><h3 id="parameter" tabindex="-1">Parameter <a class="header-anchor" href="#parameter" aria-label="Permalink to “Parameter”">​</a></h3><ul><li>Also called <strong>param</strong>.</li><li>A unit of data inside an action phrase. <ul><li>Some params may determine which action is chosen, but most are values given to the final bytecode instruction and will appear in the JSON intermediary step.</li></ul></li><li>Also a property-value pair for dialog and serial dialog settings.</li></ul><h3 id="block" tabindex="-1">Block <a class="header-anchor" href="#block" aria-label="Permalink to “Block”">​</a></h3><ul><li>Generally what falls inside a pair of matching curly braces (<code>{}</code>). Might also include the tokens right before, e.g. the script name in a script definition (<code>script_name {}</code>).</li></ul><h3 id="literal" tabindex="-1">Literal <a class="header-anchor" href="#literal" aria-label="Permalink to “Literal”">​</a></h3><ul><li>A value of a literal type (e.g. <code>100</code> is a number literal). Contrast this with a reference like a variable name, which might refer to a number value and could be used in many of the same places as a number, but is not a number <em>literal</em>.</li></ul><h2 id="dictionary-syntax" tabindex="-1">Dictionary Syntax <a class="header-anchor" href="#dictionary-syntax" aria-label="Permalink to “Dictionary Syntax”">​</a></h2><ul><li>I&#39;ll use <code>&lt;&gt;</code> to indicate &quot;insert item here&quot; in a syntax dictionary entry.</li><li>The insert usually takes the form of <code>&lt;type&gt;</code> or <code>&lt;purpose: type&gt;</code>, where the type might be a primitive type (e.g. <code>number</code>) or a larger grammatical unit (e.g. <code>entity identifier</code>).</li><li>Type suffixes: <ul><li><code>[]</code>: that insert is allowed to be expanded in a action param expansion. (Comma separated, wrapped in brackets.) <ul><li>e.g. <code>wait &lt;duration[]&gt;;</code> can become <code>wait 1;</code> or <code>wait [1, 2];</code></li></ul></li><li><code>?</code>: zero or one</li><li><code>*</code>: zero or more</li><li><code>+</code>: one or more</li></ul></li><li>Anything in the insert wrapped in quotes is a literal word, not a lookup to another pattern. This is done when the word is optional or has other repeat properties. <ul><li>e.g. <code>&lt;&quot;script&quot;?&gt;</code> means the word <code>script</code> is optional in the pattern.</li></ul></li><li>All (or almost all) single tokens that are one of the three <a href="./primitive_types.html">primitive types</a> (number, string, boolean) may be replaced by a constant, even if the dictionary entry doesn&#39;t say as much. This only goes for inserted values in the phrase, not keywords.</li></ul>',19)])])}const p=a(r,[["render",l]]);export{u as __pageData,p as default};
