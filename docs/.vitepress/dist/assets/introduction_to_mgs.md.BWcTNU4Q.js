import{_ as t,c as a,o as i,ah as n}from"./chunks/framework.l_r_SdPt.js";const g=JSON.parse('{"title":"Introduction to MGS","description":"","frontmatter":{},"headers":[],"relativePath":"introduction_to_mgs.md","filePath":"introduction_to_mgs.md"}'),r={name:"introduction_to_mgs.md"};function o(s,e,l,d,h,c){return i(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="introduction-to-mgs" tabindex="-1">Introduction to MGS <a class="header-anchor" href="#introduction-to-mgs" aria-label="Permalink to “Introduction to MGS”">​</a></h1><p>MageGameScript (MGS) is a <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noreferrer">custom scripting language</a> that compiles to Mage Game Engine (MGE) bytecode. JSON is the intermediate step between the MGS parser and the MGE <a href="./encoder.html">encoder</a>.</p><h2 id="philosophy" tabindex="-1">Philosophy <a class="header-anchor" href="#philosophy" aria-label="Permalink to “Philosophy”">​</a></h2><p>MGS v1 (&quot;natlang&quot;) was designed to use natural language-like phrases to make actions easier to read and write, but in practice it only made them easier to <em>read</em>; keywords and subphrases were easy to confuse with each other, and it was hard to remember which prepositions were strictly necessary. Also, recursive or non-fixed-length structures were not possible due to the way the old parser worked.</p><p>MGS v2 (&quot;mathlang&quot;) instead reduces ambiguity by breaking logical concepts into modular, mathlike structures which can be combined with operators. This makes syntax much more uniform, and allows for more complex and recursive structures.</p><p>For an example, there are several actions to rotate an entity toward a specific direction. The natlang phrases sounded like natural English, but as a result the keywords in the phrase varied:</p><ul><li><code>turn entity Bob north;</code></li><li><code>turn entity Bob toward entity Alice;</code></li><li><code>turn entity Bob toward geometry stick;</code></li><li><code>rotate entity Bob 1;</code></li></ul><p>Instead, Mathlang takes the concept of an entity having a &quot;direction&quot; and uses that as the LHS of an <a href="./actions.html#assign-direction-value">assignment operation</a> (or an <a href="./actions.html#change-int-value">op-equals operation</a>), with a few types of compatible RHSs:</p><ul><li><code>entity Bob direction = north;</code></li><li><code>entity Bob direction = entity Alice;</code></li><li><code>entity Bob direction = geometry stick;</code></li><li><code>entity Bob direction += 1;</code></li></ul><p>The <code>direction</code> property is an artificial construct; it isn&#39;t a value that&#39;s being changed to the value of the RHS, at least not literally. Still, the mathlike uniformity makes these phrases easy to write, and no harder to read.</p><h2 id="new-features" tabindex="-1">New Features <a class="header-anchor" href="#new-features" aria-label="Permalink to “New Features”">​</a></h2><ul><li><strong>Error recovery</strong>: The parser no longer stops on invalid syntax, meaning multiple errors can be printed in one go.</li><li><strong><a href="./expressions_and_operators.html">Expressions</a></strong>: Math no longer needs to be handled like assembly instructions, one operation at a time. Any value that can be checked may now be included in expressions, including engine flags like <code>debug_mode</code>. Expressions are flattened using a register system to hold temporary values, but in practice not very many of these temporary values are needed.</li><li><strong><a href="./fns.html">Fns</a></strong>: Macros, templates, inline functions, whatever you want to call them — these are like copy_script but will swap out tokens based on what they were passed in their args when called. This can be recursive. This leverages the existing <a href="./constants.html">constants system</a>.</li><li><strong><a href="./script_control_flow.html#return">Returning a value</a></strong>: Fns and scripts can add a value to a &quot;return register&quot; (a dedicated int variable) before jumping to the end of their action list. &quot;Callers&quot; can intercept this value and store it or use it as they like.</li><li><strong><a href="./json_literals.html">JSON literals</a></strong>: Actions (particularly novel actions) may be written out in JSON inside an MGS file. No need to keep script/dialog/serial_dialog JSON files around.</li><li><strong>Define-in-place scripts</strong>: Like with <a href="./actions.html#show-dialog">Show Dialog</a> and <a href="./actions.html#show-serial-dialog">Show Serial Dialog</a>, scripts most places can now be defined in place instead of used only by reference. This can be done recursively.</li><li><strong><a href="./encoder.html#cli-encoder">CLI</a> and <a href="./encoder.html#web-encoder">web</a> versions for MGS parsing</strong>: No special handling required when encoding the game; the WASM additions are invisible when it comes to generating the new binary data file.</li><li><strong><a href="./what_youll_need.html#syntax-colors">Syntax colors</a></strong>: TextMate grammars have been working for some time, and are generally kept up to date. Works with Sublime, VSCode, TextMate. The VSCode plugin is available on the VSCode extension marketplace.</li></ul><h2 id="wip-features" tabindex="-1">WIP Features <a class="header-anchor" href="#wip-features" aria-label="Permalink to “WIP Features”">​</a></h2><ul><li>IntelliJ colors: Got it working once, gotta get it working again!</li><li><strong><a href="./arrays.html">Arrays</a></strong>: The MGS side is fully supported, including method daisy chains. QOL features include <code>.map()</code> and <code>.for_each()</code>, which can refer to <a href="./fns.html">fns</a> by name or work off a given lambda. The engine side is starting to support basic features and is the current dev focus.</li><li><strong>Language server</strong>: Still investigating. The tree-sitter pass alone should contain enough information for basic features like symbol renaming and supplemental syntax coloring, as queries can target relevant nodes like entity names. (Map JSON files and the like must also be included in this analysis, however.)</li></ul><h2 id="using-the-parser" tabindex="-1">Using the Parser <a class="header-anchor" href="#using-the-parser" aria-label="Permalink to “Using the Parser”">​</a></h2><p>All files within <code>SD_Card/MAGE/scenario_source_files/</code> with filenames ending in <code>.mgs</code> will be parsed by the MGS parser. (See <a href="./what_youll_need.html#mage"><code>MAGE/</code></a>) All that is required is the tree-sitter engine and the MGS language grammar, both WASM. Both have been attached to the existing <a href="./encoder.html">CLI/web encoder</a> for the game.</p><p>To alter the grammar, you must make changes in <code>grammar.js</code>, rebuild the grammar using tree-sitter (targeting WASM), and then rebuild the library using Vite. That final step is required for seeing the changes in the MGE encoder, but not necessary for using the tree-sitter playground or running the language unit tests.</p>',17)])])}const m=t(r,[["render",o]]);export{g as __pageData,m as default};
