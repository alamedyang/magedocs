import{_ as e,o as t,c as o,a}from"./app-oyGKrQVR.js";const i={},n=a('<h1 id="script-slots" tabindex="-1"><a class="header-anchor" href="#script-slots" aria-hidden="true">#</a> Script Slots</h1><p>Multiple <a href="scripts">scripts</a> can run at the same time (strictly speaking, they all take turns one after the other during any single game tick), but you cannot arbitrarily run an indefinite number of scripts. Instead, entities and maps have &quot;script slots&quot; that are each able to run one script.</p><ul><li>Each <a href="entities">entity</a> has: <ul><li>one <a href="#on-interact"><code>on_interact</code></a> slot</li><li>one <a href="#on-tick"><code>on_tick</code></a> slot</li><li>one <a href="#on-look"><code>on_look</code></a> slot</li></ul></li><li>The currently-loaded <a href="maps">map</a> has: <ul><li>one <a href="#on-load"><code>on_load</code></a> slot</li><li>one <a href="#on-tick"><code>on_tick</code></a> slot</li><li>one <a href="#on-look"><code>on_look</code></a> slot</li></ul></li><li>There is also <a href="commands">command</a> slot for the serial <a href="terminal">terminal</a>.</li></ul><p>#verifyme — do the <code>on_look</code> slots use the <code>command</code> slot? They have their own space on the entity struct, so....</p><h2 id="on-interact" tabindex="-1"><a class="header-anchor" href="#on-interact" aria-hidden="true">#</a> <code>on_interact</code></h2><p>If the player presses the interact button and the interact hitbox hits another entity, that entity&#39;s <code>on_interact</code> script will run. (You can watch this happen with <a href="debug_tools#vector-view">vector view</a>.)</p><p>Scripts run in the <code>on_interact</code> slot will stop once they reach the end of their list of actions. Very commonly, a <a href="entity_types#character-entity">character entity</a>&#39;s <code>on_interact</code> script will be the start script of their <a href="dialogs">dialog</a> tree.</p><p>If the script in this slot jumps to another script at some point, interacting with that entity again will result in the last-used script being run again, not whatever the original <code>on_interact</code> script was. Therefore, if you wish an entity to begin all interactions with the first script in its interact tree, you must explicitly <a href="actions/SET_ENTITY_INTERACT_SCRIPT">reset</a> its <code>on_interact</code> script at the end of each of its script <a href="techniques/beginnings_middles_and_ends">branches</a>.</p><h2 id="on-tick" tabindex="-1"><a class="header-anchor" href="#on-tick" aria-hidden="true">#</a> <code>on_tick</code></h2><p><code>on_tick</code> scripts continuously evaluate every game tick. Once an <code>on_tick</code> script reaches the end of its list of <a href="actions">actions</a>, the script will return to the beginning of the currently set script and run again on the next game tick.</p><div class="custom-container danger"><p class="custom-container-title">DANGER</p><p>This means that if you <a href="actions/RUN_SCRIPT">goto</a> the same script you started from as the <code>on_tick</code> script&#39;s last action, the script slot will NEVER give up its turn! You probably want to use <a href="actions/SET_ENTITY_TICK_SCRIPT">SET_ENTITY_TICK_SCRIPT</a> or <a href="actions/SET_MAP_TICK_SCRIPT">SET_MAP_TICK_SCRIPT</a> instead, which will set the target script for that slot but NOT immediately execute like <a href="actions/RUN_SCRIPT">RUN_SCRIPT</a> would.</p></div><p>A map&#39;s <code>on_tick</code> script slot is a logical place for a script that watches for whether the player enters a <a href="techniques/doors">doorway</a>, but <code>on_tick</code> scripts are useful for other kinds of watch scripts, too, such as changing an entity&#39;s idle behavior after a condition has been met.</p><p><code>on_tick</code> slots are what you should use if you want to be able to interrupt or abort a script at an arbitrary place or time e.g. with a button press, or when the player crosses a <a href="vector_objects">collision trigger</a>, etc.</p><p>To terminate an <code>on_tick</code> script, it must <a href="actions/RUN_SCRIPT">goto</a> <a href="scripts#null_script">null_script</a> as one of its actions, or another script must tell it to switch to <code>null_script</code>.</p><h2 id="on-load" tabindex="-1"><a class="header-anchor" href="#on-load" aria-hidden="true">#</a> <code>on_load</code></h2><p>A maps&#39;s <code>on_load</code> script runs when a map is first loaded. Like an <code>on_interact</code> script, once the script reaches the end of its list of actions, the script stops.</p><p>These are useful for identifying and re-implementing the &quot;permanent&quot; changes the player has done on that map, as well as making decisions as to whether a <a href="techniques/cutscenes">cutscene</a> should be played on that map upon <a href="map_loads">load</a> (e.g. at the beginning of the game).</p><h2 id="on-look" tabindex="-1"><a class="header-anchor" href="#on-look" aria-hidden="true">#</a> <code>on_look</code></h2><p><code>on_look</code> scripts are run when the player uses the <code>look</code> command in the <a href="terminal">terminal</a>.</p><p><code>look</code> on its own triggers the maps&#39;s <code>on_look</code> script. <code>look</code> + the <a href="variables#printing-current-values">current name</a> of an entity will trigger that entity&#39;s <code>on_look</code> script.</p><p>If multiple entities in a map have the same <strong>given name</strong> (the name assigned to that entity within Tiled), and one or more of those entities have had their name changed, <code>look</code>ing at any of them will use the current name of the first entity the map found with the shared <strong>given name</strong>.</p><p><code>on_look</code> scripts can be overridden with a manual <a href="commands">command</a> registration.</p><h2 id="one-slot-one-script" tabindex="-1"><a class="header-anchor" href="#one-slot-one-script" aria-hidden="true">#</a> One Slot, One Script</h2><p>Importantly, a script slot can only run one script — if a script jumps to another script (either with <a href="actions/RUN_SCRIPT">RUN_SCRIPT</a> or by <a href="conditional_gotos">script jumping via some kind of logic check</a>) the current script is <em>completely abandoned</em> and the new script is run instead. It is therefore important to check the order in which actions are given, as any action listed after a script change will be ignored.</p><p>There is no nested callback structure, no child function returning something to its parent function, nor anything like that.</p><p>Nor is it possible to do more than one logic check simultaneously. If you want to check multiple conditions at once, you must branch to a different script for each aspect of the fail condition and let the remainder of the original script contain the actions for the success condition. <a href="mgs/mgs_natlang">MGS Natlang</a> simplifies this a little bit by allowing multiple conditions to be written per behavior block, but these conditions can only be linked with OR (<code>||</code>) not AND (<code>&amp;&amp;</code>) for this reason; the <a href="mgs/advanced_syntax#if-and-else">if and else</a> macro expands each OR condition into an individual logic check and jump, jumping to a common <a href="mgs/advanced_syntax#labels">label</a> index for all shared <code>{}</code> behavior.</p>',26),r=[n];function s(c,h){return t(),o("div",null,r)}const d=e(i,[["render",s],["__file","script_slots.html.vue"]]);export{d as default};
